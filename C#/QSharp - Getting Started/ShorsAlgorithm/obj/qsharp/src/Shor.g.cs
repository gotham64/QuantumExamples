//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"FactorInteger\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":32,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":24}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"number\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":25},\"Item2\":{\"Line\":1,\"Column\":31}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"useRobustPhaseEstimation\"]},\"Type\":{\"Case\":\"Bool\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":39},\"Item2\":{\"Line\":1,\"Column\":63}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Bool\"}]]},\"ReturnType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Uses Shor's algorithm to factor the parameter `number`\",\"\",\" # Input\",\" ## number\",\" An integer to be factored\",\" ## useRobustPhaseEstimation\",\" If set to true, we use Microsoft.Quantum.Characterization.RobustPhaseEstimation and\",\" Microsoft.Quantum.Characterization.QuantumPhaseEstimation otherwise\",\"\",\" # Output\",\" Pair of numbers p > 1 and q > 1 such that p⋅q = `number`\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"FactorInteger\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":32,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":24}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":120,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":35},\"Item2\":{\"Line\":1,\"Column\":44}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":52},\"Item2\":{\"Line\":1,\"Column\":59}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"power\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":67},\"Item2\":{\"Line\":1,\"Column\":72}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":80},\"Item2\":{\"Line\":1,\"Column\":86}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Interprets `target` as encoding unsigned little-endian integer k\",\" and performs transformation |k⟩ ↦ |gᵖ⋅k mod N ⟩ where\",\" p is `power`, g is `generator` and N is `modulus`.\",\"\",\" # Input\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## power\",\" Power of `generator` by which `target` is multiplied.\",\" ## target\",\" Register interpreted as LittleEndian which is multiplied by\",\" given power of the generator. The multiplication is performed modulo\",\" `modulus`.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":120,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"Documentation\":[]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":120,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":3,\"Column\":8},\"Item2\":{\"Line\":3,\"Column\":17}},\"Documentation\":[\"automatically generated QsAdjoint specialization for ShorsAlgorithm.ApplyOrderFindingOracle\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlled\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":120,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":3,\"Column\":8},\"Item2\":{\"Line\":3,\"Column\":17}},\"Documentation\":[\"automatically generated QsControlled specialization for ShorsAlgorithm.ApplyOrderFindingOracle\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlledAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":120,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":3,\"Column\":8},\"Item2\":{\"Line\":3,\"Column\":17}},\"Documentation\":[\"automatically generated QsControlledAdjoint specialization for ShorsAlgorithm.ApplyOrderFindingOracle\"]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"EstimatePeriod\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":155,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":25}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":26},\"Item2\":{\"Line\":1,\"Column\":35}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":43},\"Item2\":{\"Line\":1,\"Column\":50}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"useRobustPhaseEstimation\"]},\"Type\":{\"Case\":\"Bool\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":58},\"Item2\":{\"Line\":1,\"Column\":82}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Bool\"}]]},\"ReturnType\":{\"Case\":\"Int\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Finds a multiplicative order of the generator\",\" in the residue ring Z mod `modulus`.\",\"\",\" # Input\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## useRobustPhaseEstimation\",\" If set to true, we use Microsoft.Quantum.Characterization.RobustPhaseEstimation and\",\" Microsoft.Quantum.Characterization.QuantumPhaseEstimation\",\"\",\" # Output\",\" The period ( multiplicative order ) of the generator mod `modulus`\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"ShorsAlgorithm\",\"Name\":\"EstimatePeriod\"},\"Attributes\":[],\"SourceFile\":\"C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs\",\"Position\":{\"Item1\":155,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":25}},\"Documentation\":[]}")]
#line hidden
namespace ShorsAlgorithm
{
    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.Body, 33, 121)]
    public partial class FactorInteger : Operation<(Int64,Boolean), (Int64,Int64)>, ICallable
    {
        public FactorInteger(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Boolean)>, IApplyData
        {
            public In((Int64,Boolean) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        public class Out : QTuple<(Int64,Int64)>, IApplyData
        {
            public Out((Int64,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "FactorInteger";
        String ICallable.FullName => "ShorsAlgorithm.FactorInteger";
        public static OperationInfo<(Int64,Boolean), (Int64,Int64)> Info => new OperationInfo<(Int64,Boolean), (Int64,Int64)>(typeof(FactorInteger));
        protected ICallable<String, QVoid> MicrosoftQuantumIntrinsicMessage
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathGreatestCommonDivisorI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathMaxI
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathRandomInt
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Boolean), Int64> EstimatePeriod
        {
            get;
            set;
        }

        public override Func<(Int64,Boolean), (Int64,Int64)> Body => (__in__) =>
        {
            var (number,useRobustPhaseEstimation) = __in__;
#line 36 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            if (((number % 2L) == 0L))
            {
#line 37 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                MicrosoftQuantumIntrinsicMessage.Apply("An even number has been passed; 2 is the factor.");
#line 38 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                return ((number / 2L), 2L);
            }

#line 43 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            var coprimeCandidate = (MicrosoftQuantumMathRandomInt.Apply((number - 2L)) + 1L);
#line 48 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            if (MicrosoftQuantumMathIsCoprimeI.Apply((coprimeCandidate, number)))
            {
#line 52 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                MicrosoftQuantumIntrinsicMessage.Apply(String.Format("Estimating period of {0}", coprimeCandidate));
#line 57 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                var period = EstimatePeriod.Apply((coprimeCandidate, number, useRobustPhaseEstimation));
#line 60 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                if (((period % 2L) == 0L))
                {
#line 64 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    var halfPower = MicrosoftQuantumMathExpModI.Apply((coprimeCandidate, (period / 2L), number));
#line 68 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    if ((halfPower != (number - 1L)))
                    {
#line 73 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        var factor = MicrosoftQuantumMathMaxI.Apply((MicrosoftQuantumMathGreatestCommonDivisorI.Apply(((halfPower - 1L), number)), MicrosoftQuantumMathGreatestCommonDivisorI.Apply(((halfPower + 1L), number))));
#line 76 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        return (factor, (number / factor));
                    }
                    else
                    {
#line 80 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        throw new ExecutionFailException("Residue xᵃ = -1 (mod N) where a is a period.");
                    }
                }
                else
                {
#line 85 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    throw new ExecutionFailException("Period is odd.");
                }
            }
            else
            {
#line 91 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                var gcd = MicrosoftQuantumMathGreatestCommonDivisorI.Apply((number, coprimeCandidate));
#line 95 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                MicrosoftQuantumIntrinsicMessage.Apply(String.Format("We have guessed a divisor of {0} to be {1} by accident.", number, gcd));
#line 98 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                return (gcd, (number / gcd));
            }
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumIntrinsicMessage = this.Factory.Get<ICallable<String, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.Message));
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
            this.MicrosoftQuantumMathGreatestCommonDivisorI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.GreatestCommonDivisorI));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
            this.MicrosoftQuantumMathMaxI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.MaxI));
            this.MicrosoftQuantumMathRandomInt = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.RandomInt));
            this.EstimatePeriod = this.Factory.Get<ICallable<(Int64,Int64,Boolean), Int64>>(typeof(EstimatePeriod));
        }

        public override IApplyData __dataIn((Int64,Boolean) data) => new In(data);
        public override IApplyData __dataOut((Int64,Int64) data) => new Out(data);
        public static System.Threading.Tasks.Task<(Int64,Int64)> Run(IOperationFactory __m__, Int64 number, Boolean useRobustPhaseEstimation)
        {
            return __m__.Run<FactorInteger, (Int64,Boolean), (Int64,Int64)>((number, useRobustPhaseEstimation));
        }
    }

    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.Body, 121, 156)]
    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.Adjoint, 121, 156)]
    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.Controlled, 121, 156)]
    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.ControlledAdjoint, 121, 156)]
    public partial class ApplyOrderFindingOracle : Unitary<(Int64,Int64,Int64,IQArray<Qubit>)>, ICallable
    {
        public ApplyOrderFindingOracle(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Int64,IQArray<Qubit>)>, IApplyData
        {
            public In((Int64,Int64,Int64,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item4)?.Qubits;
                }
            }
        }

        String ICallable.Name => "ApplyOrderFindingOracle";
        String ICallable.FullName => "ShorsAlgorithm.ApplyOrderFindingOracle";
        public static OperationInfo<(Int64,Int64,Int64,IQArray<Qubit>), QVoid> Info => new OperationInfo<(Int64,Int64,Int64,IQArray<Qubit>), QVoid>(typeof(ApplyOrderFindingOracle));
        protected ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian> MicrosoftQuantumArithmeticLittleEndian
        {
            get;
            set;
        }

        protected IUnitary<(Int64,Int64,Microsoft.Quantum.Arithmetic.LittleEndian)> MicrosoftQuantumArithmeticMultiplyByModularInteger
        {
            get;
            set;
        }

        protected ICallable<(Boolean,String), QVoid> MicrosoftQuantumDiagnosticsFact
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Int64,IQArray<Qubit>), QVoid> Body => (__in__) =>
        {
            var (generator,modulus,power,target) = __in__;
#line 125 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 135 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Apply((MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(Int64,Int64,Int64,IQArray<Qubit>), QVoid> AdjointBody => (__in__) =>
        {
            var (generator,modulus,power,target) = __in__;
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Adjoint.Apply((MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Int64,Int64,Int64,IQArray<Qubit>)), QVoid> ControlledBody => (__in__) =>
        {
            var (__controlQubits__,(generator,modulus,power,target)) = __in__;
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Controlled.Apply((__controlQubits__, (MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target))));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Int64,Int64,Int64,IQArray<Qubit>)), QVoid> ControlledAdjointBody => (__in__) =>
        {
            var (__controlQubits__,(generator,modulus,power,target)) = __in__;
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 121 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Adjoint.Controlled.Apply((__controlQubits__, (MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target))));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumArithmeticLittleEndian = this.Factory.Get<ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndian));
            this.MicrosoftQuantumArithmeticMultiplyByModularInteger = this.Factory.Get<IUnitary<(Int64,Int64,Microsoft.Quantum.Arithmetic.LittleEndian)>>(typeof(Microsoft.Quantum.Arithmetic.MultiplyByModularInteger));
            this.MicrosoftQuantumDiagnosticsFact = this.Factory.Get<ICallable<(Boolean,String), QVoid>>(typeof(Microsoft.Quantum.Diagnostics.Fact));
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
        }

        public override IApplyData __dataIn((Int64,Int64,Int64,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __dataOut(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Int64 generator, Int64 modulus, Int64 power, IQArray<Qubit> target)
        {
            return __m__.Run<ApplyOrderFindingOracle, (Int64,Int64,Int64,IQArray<Qubit>), QVoid>((generator, modulus, power, target));
        }
    }

    [SourceLocation("C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs", OperationFunctor.Body, 156, -1)]
    public partial class EstimatePeriod : Operation<(Int64,Int64,Boolean), Int64>, ICallable
    {
        public EstimatePeriod(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Boolean)>, IApplyData
        {
            public In((Int64,Int64,Boolean) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "EstimatePeriod";
        String ICallable.FullName => "ShorsAlgorithm.EstimatePeriod";
        public static OperationInfo<(Int64,Int64,Boolean), Int64> Info => new OperationInfo<(Int64,Int64,Boolean), Int64>(typeof(EstimatePeriod));
        protected IUnitary<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian)> MicrosoftQuantumArithmeticApplyXorInPlace
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian> MicrosoftQuantumArithmeticLittleEndian
        {
            get;
            set;
        }

        protected ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Microsoft.Quantum.Arithmetic.BigEndian> MicrosoftQuantumArithmeticLittleEndianAsBigEndian
        {
            get;
            set;
        }

        protected ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Int64> MicrosoftQuantumArithmeticMeasureInteger
        {
            get;
            set;
        }

        protected IUnitary<(Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>,Microsoft.Quantum.Arithmetic.BigEndian)> MicrosoftQuantumCharacterizationQuantumPhaseEstimation
        {
            get;
            set;
        }

        protected ICallable<(Int64,Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>), Double> MicrosoftQuantumCharacterizationRobustPhaseEstimation
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> MicrosoftQuantumConvertIntAsDouble
        {
            get;
            set;
        }

        protected ICallable<(Boolean,Boolean,String), QVoid> MicrosoftQuantumDiagnosticsEqualityFactB
        {
            get;
            set;
        }

        protected Allocate Allocate
        {
            get;
            set;
        }

        protected ICallable<String, QVoid> MicrosoftQuantumIntrinsicMessage
        {
            get;
            set;
        }

        protected Release Release
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, QVoid> MicrosoftQuantumIntrinsicResetAll
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathAbsI
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathBitSizeI
        {
            get;
            set;
        }

        protected ICallable<(Microsoft.Quantum.Math.Fraction,Int64), Microsoft.Quantum.Math.Fraction> MicrosoftQuantumMathContinuedFractionConvergentI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Microsoft.Quantum.Math.Fraction> MicrosoftQuantumMathFraction
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathGreatestCommonDivisorI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        protected ICallable<QVoid, Double> MicrosoftQuantumMathPI
        {
            get;
            set;
        }

        protected ICallable<Double, Int64> MicrosoftQuantumMathRound
        {
            get;
            set;
        }

        protected ICallable<IUnitary, Microsoft.Quantum.Oracles.DiscreteOracle> MicrosoftQuantumOraclesDiscreteOracle
        {
            get;
            set;
        }

        protected IUnitary<(Int64,Int64,Int64,IQArray<Qubit>)> ApplyOrderFindingOracle
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Boolean), Int64> Body => (__in__) =>
        {
            var (generator,modulus,useRobustPhaseEstimation) = __in__;
#line 158 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            MicrosoftQuantumDiagnosticsEqualityFactB.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), true, "`generator` and `modulus` must be co-prime"));
#line 161 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            var result = 1L;
#line 164 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            var bitsize = MicrosoftQuantumMathBitSizeI.Apply(modulus);
#line 168 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            var bitsPrecision = ((2L * bitsize) + 1L);
#line 170 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            while (true)
            {
#line 174 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                var dyadicFractionNum = 0L;
#line hidden
                {
#line 178 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    var eigenstateRegister = Allocate.Apply(bitsize);
#line hidden
                    bool __arg1__ = true;
                    try
                    {
#line 184 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        var eigenstateRegisterLE = new Microsoft.Quantum.Arithmetic.LittleEndian(eigenstateRegister);
#line 185 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        MicrosoftQuantumArithmeticApplyXorInPlace.Apply((1L, eigenstateRegisterLE));
#line 189 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        var oracle = new Microsoft.Quantum.Oracles.DiscreteOracle(ApplyOrderFindingOracle.Partial(new Func<(Int64,IQArray<Qubit>), (Int64,Int64,Int64,IQArray<Qubit>)>((__arg2__) => (generator, modulus, __arg2__.Item1, __arg2__.Item2))));
#line 193 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        if (useRobustPhaseEstimation)
                        {
#line 197 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                            var phase = MicrosoftQuantumCharacterizationRobustPhaseEstimation.Apply((bitsPrecision, oracle, eigenstateRegisterLE.Data));
#line 202 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                            dyadicFractionNum = MicrosoftQuantumMathRound.Apply((((phase * MicrosoftQuantumConvertIntAsDouble.Apply(2L.Pow(bitsPrecision))) / 2D) / MicrosoftQuantumMathPI.Apply(QVoid.Instance)));
                        }
                        else
                        {
#line hidden
                            {
#line 207 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                                var register = Allocate.Apply(bitsPrecision);
#line hidden
                                bool __arg3__ = true;
                                try
                                {
#line 208 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                                    var dyadicFractionNumerator = new Microsoft.Quantum.Arithmetic.LittleEndian(register);
#line 214 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                                    MicrosoftQuantumCharacterizationQuantumPhaseEstimation.Apply((oracle, eigenstateRegisterLE.Data, MicrosoftQuantumArithmeticLittleEndianAsBigEndian.Apply(dyadicFractionNumerator)));
#line 219 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                                    dyadicFractionNum = MicrosoftQuantumArithmeticMeasureInteger.Apply(dyadicFractionNumerator);
                                }
#line hidden
                                catch
                                {
                                    __arg3__ = false;
                                    throw;
                                }
#line hidden
                                finally
                                {
                                    if (__arg3__)
                                    {
#line hidden
                                        Release.Apply(register);
                                    }
                                }
                            }
                        }

#line 225 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                        MicrosoftQuantumIntrinsicResetAll.Apply(eigenstateRegister);
                    }
#line hidden
                    catch
                    {
                        __arg1__ = false;
                        throw;
                    }
#line hidden
                    finally
                    {
                        if (__arg1__)
                        {
#line hidden
                            Release.Apply(eigenstateRegister);
                        }
                    }
                }

#line 230 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                if ((dyadicFractionNum == 0L))
                {
#line 231 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    throw new ExecutionFailException("We measured 0 for the numerator");
                }

#line 236 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                MicrosoftQuantumIntrinsicMessage.Apply(String.Format("Estimated eigenvalue is {0}/2^{1}.", dyadicFractionNum, bitsPrecision));
#line 240 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                var (numerator,period) = MicrosoftQuantumMathContinuedFractionConvergentI.Apply((new Microsoft.Quantum.Math.Fraction((dyadicFractionNum, 2L.Pow(bitsPrecision))), modulus)).Data;
#line 245 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                var (numeratorAbs,periodAbs) = (MicrosoftQuantumMathAbsI.Apply(numerator), MicrosoftQuantumMathAbsI.Apply(period));
#line 249 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                MicrosoftQuantumIntrinsicMessage.Apply((String.Format("Estimated divisor of period is {0}, ", periodAbs) + String.Format(" we have projected on eigenstate marked by {0}.", numeratorAbs)));
#line 253 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                result = ((periodAbs * result) / MicrosoftQuantumMathGreatestCommonDivisorI.Apply((result, periodAbs)));
                if ((MicrosoftQuantumMathExpModI.Apply((generator, result, modulus)) == 1L))
                {
                    break;
                }
                else
                {
#line 263 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
                    MicrosoftQuantumIntrinsicMessage.Apply(("It looks like the period has divisors and we have " + "found only a divisor of the period. Trying again ..."));
                }
            }

#line 267 "C:/Users/Chuck/Desktop/Module%206%20-%20Additional%20QA/Code/C%23/QSharp%20-%20Getting%20Started/ShorsAlgorithm/Shor.qs"
            return result;
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumArithmeticApplyXorInPlace = this.Factory.Get<IUnitary<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian)>>(typeof(Microsoft.Quantum.Arithmetic.ApplyXorInPlace));
            this.MicrosoftQuantumArithmeticLittleEndian = this.Factory.Get<ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndian));
            this.MicrosoftQuantumArithmeticLittleEndianAsBigEndian = this.Factory.Get<ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Microsoft.Quantum.Arithmetic.BigEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndianAsBigEndian));
            this.MicrosoftQuantumArithmeticMeasureInteger = this.Factory.Get<ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Int64>>(typeof(Microsoft.Quantum.Arithmetic.MeasureInteger));
            this.MicrosoftQuantumCharacterizationQuantumPhaseEstimation = this.Factory.Get<IUnitary<(Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>,Microsoft.Quantum.Arithmetic.BigEndian)>>(typeof(Microsoft.Quantum.Characterization.QuantumPhaseEstimation));
            this.MicrosoftQuantumCharacterizationRobustPhaseEstimation = this.Factory.Get<ICallable<(Int64,Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>), Double>>(typeof(Microsoft.Quantum.Characterization.RobustPhaseEstimation));
            this.MicrosoftQuantumConvertIntAsDouble = this.Factory.Get<ICallable<Int64, Double>>(typeof(Microsoft.Quantum.Convert.IntAsDouble));
            this.MicrosoftQuantumDiagnosticsEqualityFactB = this.Factory.Get<ICallable<(Boolean,Boolean,String), QVoid>>(typeof(Microsoft.Quantum.Diagnostics.EqualityFactB));
            this.Allocate = this.Factory.Get<Allocate>(typeof(Microsoft.Quantum.Intrinsic.Allocate));
            this.MicrosoftQuantumIntrinsicMessage = this.Factory.Get<ICallable<String, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.Message));
            this.Release = this.Factory.Get<Release>(typeof(Microsoft.Quantum.Intrinsic.Release));
            this.MicrosoftQuantumIntrinsicResetAll = this.Factory.Get<ICallable<IQArray<Qubit>, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.ResetAll));
            this.MicrosoftQuantumMathAbsI = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.AbsI));
            this.MicrosoftQuantumMathBitSizeI = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.BitSizeI));
            this.MicrosoftQuantumMathContinuedFractionConvergentI = this.Factory.Get<ICallable<(Microsoft.Quantum.Math.Fraction,Int64), Microsoft.Quantum.Math.Fraction>>(typeof(Microsoft.Quantum.Math.ContinuedFractionConvergentI));
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
            this.MicrosoftQuantumMathFraction = this.Factory.Get<ICallable<(Int64,Int64), Microsoft.Quantum.Math.Fraction>>(typeof(Microsoft.Quantum.Math.Fraction));
            this.MicrosoftQuantumMathGreatestCommonDivisorI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.GreatestCommonDivisorI));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
            this.MicrosoftQuantumMathPI = this.Factory.Get<ICallable<QVoid, Double>>(typeof(Microsoft.Quantum.Math.PI));
            this.MicrosoftQuantumMathRound = this.Factory.Get<ICallable<Double, Int64>>(typeof(Microsoft.Quantum.Math.Round));
            this.MicrosoftQuantumOraclesDiscreteOracle = this.Factory.Get<ICallable<IUnitary, Microsoft.Quantum.Oracles.DiscreteOracle>>(typeof(Microsoft.Quantum.Oracles.DiscreteOracle));
            this.ApplyOrderFindingOracle = this.Factory.Get<IUnitary<(Int64,Int64,Int64,IQArray<Qubit>)>>(typeof(ApplyOrderFindingOracle));
        }

        public override IApplyData __dataIn((Int64,Int64,Boolean) data) => new In(data);
        public override IApplyData __dataOut(Int64 data) => new QTuple<Int64>(data);
        public static System.Threading.Tasks.Task<Int64> Run(IOperationFactory __m__, Int64 generator, Int64 modulus, Boolean useRobustPhaseEstimation)
        {
            return __m__.Run<EstimatePeriod, (Int64,Int64,Boolean), Int64>((generator, modulus, useRobustPhaseEstimation));
        }
    }
}